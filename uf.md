uf可以由数组实现，也可以由树实现，如果由树实现，则可能需要进行优化



#问题引入
题意：首先在地图上给你若干个城镇，这些城镇都可以看作点，然后告诉你哪些对城镇之间是有道路直接相连的。最后要解决的是整幅图的连通性问题。比如随意给你两个点，让你判断它们是否连通，或者问你整幅图一共有几个连通分支，也就是被分成了几个互相独立的块。像畅通工程这题，问还需要修几条路，实质就是求有几个连通分支。如果是1个连通分支，说明整幅图上的点都连起来了，
不用再修路了；如果是2个连通分支，则只要再修1条路，从两个分支中各选一个点，把它们连起来，那么所有的点都是连起来的了；如果是3个连通分支，则只要再修两条路……

说明：输入4 2   1 3   4 3。即一共有4个点，2条路。下面两行告诉你，1、3之间有条路，4、3之间有条路。那么整幅图就被分成了1-3-4和2两部分。只要再加一条路，把2和其他任意一个点连起来，畅通工程就实现了，那么这个这组数据的输出结果就是1。好了，现在编程实现这个功能吧，城镇有几百个，路有不知道多少条，而且可能有回路。 这可如何是好？ 我以前也不会呀，自从用了并查集之后，嗨，效果还真好！


#二、故事描述

并查集由一个整数型的数组和两个函数构成。数组pre[]记录了每个点的前导点是什么，函数find是查找，函数join是合并。

话说江湖上散落着各式各样的大侠，有上千个之多。
他们没有什么正当职业，整天背着剑在外面走来走去，
碰到和自己不是一路人的，就免不了要打一架。
但大侠们有一个优点就是讲义气，绝对不打自己的朋友。
而且他们信奉“朋友的朋友就是我的朋友”，
只要是能通过朋友关系串联起来的，不管拐了多少个弯，
都认为是自己人。这样一来，江湖上就形成了一个一个的群落，
通过两两之间的朋友关系串联起来。而不在同一个群落的人，
无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。
但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？ 
我们可以在每个朋友圈内推举出一个比较有名望的人，
作为该圈子的代表人物，这样，每个圈子就可以这样命名
“齐达内朋友之队”“罗纳尔多朋友之队”……两人只要互相对
一下自己的队长是不是同一个人，就可以确定敌友关系了。 
但是还有问题啊，大侠们只知道自己直接的朋友是谁，
很多人压根就不认识队长，要判断自己的队长是谁，
只能漫无目的的通过朋友的朋友关系问下去：
“你是不是队长？你是不是队长？” 这样一来，队长面子上挂不住了，
而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。
队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，
只要不搞错敌友关系就好了。于是，门派产生了。

#三、算法描述

关键特征：

①用集合中的某个元素来代表这个集合，该元素称为集合的代表元；

②一个集合内的所有元素组织成以代表元为根的树形结构；

③对于每一个元素 pre[x]指向x在树形结构上的父亲节点。如果x是根节点，则令pre[x] = x；

④对于查找操作，假设需要确定x所在的的集合，也就是确定集合的代表元。可以沿着pre[x]不断在树形结构中向上移动，直到到达根节点。

判断两个元素是否属于同一集合，只需要看他们的代表元是否相同即可。

路径压缩：  

为了加快查找速度，查找时将x到根节点路径上的所有点的pre（上级）设为根节点，该优化方法称为压缩路径。使用该优化后，平均复杂度可视为Ackerman函数的反函数，实际应用中可粗略认为其是一个常数。

用途：

1、维护无向图的连通性。支持判断两个点是否在同一连通块内，和判断增加一条边是否会产生环。

2、用在求解最小生成树的Kruskal算法里。

一般来说，一个并查集对应三个操作：初始化+查找根结点函数+合并集合函数

【初始化】

包括对所有单个的数据建立一个单独的集合（即根据题目的意思自己建立的最多可能有的集合，为下面的合并查找操作提供操作对象）。

在每一个单个的集合里面，有三个东西。

①集合所代表的数据（这个初始值根据需要自己定义，不固定） ；

②这个集合的层次通常用rank表示（一般来说，初始化的工作之一就是将每一个集合里的rank置为1）；

③这个集合的类别pre（其实就是一个指针，用来指示这个集合属于那一类，合并过后的集合，他们的pre指向的最终值一定是相同的） （有的简单题里面集合的数据就是这个集合的标号，也就是说只包含2和3，1省略了）。

初始化的时候，每一个集合的pre都是这个集合自己的标号。没有跟它同类的集合，那么这个集合的源头只能是自己了。